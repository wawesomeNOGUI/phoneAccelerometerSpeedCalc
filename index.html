<html>
    <button id="enableMotion" style="padding: 20px; font-size: 20px;" onclick="enableMotionSensors();">Enable Motion Sensors</button>
    <canvas id="myCanvas"></canvas>
    <canvas id="graphCanvas"></canvas>
    <button id="pauseGraph" onclick="pauseUnpauseGraph();">Pause Graph</button>
    <button id="outputCSV" onclick="outputCSV();">Output CSV</button>
    <div id="CSV_DATA_DIV" style="display: none;"></div>
<script>
var cnvs = document.getElementById("myCanvas");
cnvs.width = window.innerWidth;
cnvs.height = 500;
var ctx = cnvs.getContext("2d");

var graphCnvs = document.getElementById("graphCanvas");
graphCnvs.width = window.innerWidth / 2;
graphCnvs.height = 100;
//Don't Anti-Alias Scaled canvas
ctx.imageSmoothingEnabled = false;

//Scale canvas to fit user's screen
graphCnvs.style.width = "90vw";
graphCnvs.style.height = 500;

var graphCtx = graphCnvs.getContext("2d");

// store array of accel and velocity data
// store json objects {step: 0, accel: 0, vel: 0}
var accelAndVelData = {};

async function outputCSV() {
    document.getElementById("outputCSV").innerText = "Writing...";

    var textToCopy;

    for (const key in accelAndVelData) {
        // key is the time in seconds
        textToCopy += key + ", " + accelAndVelData[key]["accel"] + ", " + accelAndVelData[key]["vel"] + "\n ";
    }

    // write to clipboard
    // await navigator.clipboard.writeText(textToCopy);
    
    document.getElementById("outputCSV").innerText = "Ouput CSV";

    document.getElementById('CSV_DATA_DIV').style.display = 'block';
    document.getElementById('CSV_DATA_DIV').innerText = textToCopy;
}

function pauseUnpauseGraph() {
    if (document.getElementById("pauseGraph").innerText == "Pause Graph") {
        document.getElementById("pauseGraph").innerText = "Unpause Graph";
    } else {
        document.getElementById("pauseGraph").innerText = "Pause Graph"
    }
}

function enableMotionSensors() {
    // thank you DeepSeek for suggestion of why didn't work on IOS
    if (typeof DeviceMotionEvent.requestPermission === 'function') {
        DeviceMotionEvent.requestPermission()
            .then(permissionState => {
                if (permissionState === 'granted') {
                    window.addEventListener("devicemotion", accelerometerUpdate, true);
                } else {
                    alert("Motion permission denied");
                }
            })
            .catch(console.error);
    } else {
        // Non-iOS devices
        window.addEventListener("devicemotion", accelerometerUpdate, true);
    }

    document.getElementById("enableMotion").style.display = 'none';
}

class vector3 {
    constructor(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    mag() {
        return Math.sqrt(this.x ** 2 + this.y ** 2 + this.z ** 2);
    }

    normalize() {
        var m = this.mag();

        this.x /= m;
        this.y /= m;
        this.z /= m;
    }
}

class rotationMatrix {
    // alpha, beta, gamma in radians
    constructor(a, b, g) {
        this.a = a;
        this.b = b;
        this.g = g;

        this.ca = Math.cos(this.a);
        this.cb = Math.cos(this.b);
        this.cg = Math.cos(this.g);
        this.sa = Math.sin(this.a);
        this.sb = Math.sin(this.b);
        this.sg = Math.sin(this.g);

        // define each rotation matrix element
        this.rm = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];

        this.rm[0][0] = this.ca * this.cb;
        this.rm[0][1] = (this.ca * this.sb * this.sg) - (this.sa * this.cg);
        this.rm[0][2] = (this.ca * this.sb * this.cg) + (this.sa * this.sg);
        this.rm[1][0] = this.sa * this.cb;
        this.rm[1][1] = (this.sa * this.sb * this.sg) + (this.ca * this.cg);
        this.rm[1][2] = (this.sa * this.sb * this.cg) - (this.ca * this.sg);
        this.rm[2][0] = -this.sb;
        this.rm[2][1] = this.cb * this.sg;
        this.rm[2][2] = this.cb * this.cg;
    }

    // rotates v of type vector3
    rotateVector3(v) {
        var tmp = new vector3(0, 0, 0);

        tmp.x = this.rm[0][0] * v.x + this.rm[0][1] * v.y + this.rm[0][2] * v.z; 
        tmp.y = this.rm[1][0] * v.x + this.rm[1][1] * v.y + this.rm[1][2] * v.z; 
        tmp.z = this.rm[2][0] * v.x + this.rm[2][1] * v.y + this.rm[2][2] * v.z; 

        v.x = tmp.x;
        v.y = tmp.y;
        v.z = tmp.z;
    }
}

// vars
var samples = 0; // tracks number of IMU samples
var time = 0; // tracks time from deltaTime between samples
var vel = new vector3(0, 0, 0); // velocity in m/s
var maxVel = new vector3(0, 0, 0);
var maxAccel = new vector3(0, 0, 0);
var pos = new vector3(0, 0, 0); // position in m

var stepPrintY = 40;
var printY = stepPrintY;
function printData(context, label, data) {
    ctx.font = "40px Arial";

    var dataStr = "";
    if (typeof data == "object") {
        for (const p in data) {
            dataStr += data[p] + ", ";
        }

        // delete last comma
        dataStr = dataStr.slice(0, dataStr.length - 2);
    } else {
        dataStr = data;
    }

    context.fillText(label + dataStr, 20, printY);
    printY += stepPrintY;
}

// round the data from the IMU
function roundData(data) {
    var tmp = {};

    for (const p in data) {
        tmp[p] = Math.round(data[p] * 100) / 100;
    }

    return tmp;
}

// double integrates linear acceleration to track position
// a is in meters per second
// dt is in milliseconds
// https://developer.mozilla.org/en-US/docs/Web/API/DeviceMotionEvent
var prevAccel = new vector3(0, 0, 0);
function trackPosition(a, dt) {
    // integrate velocity using trapezoidal rule numerical integration
    vel.x += dt * 0.001 * 0.5 * (a.x + prevAccel.x);
    vel.y += dt * 0.001 * 0.5 * (a.y + prevAccel.y);
    vel.z += dt * 0.001 * 0.5 * (a.z + prevAccel.z);

    prevAccel = a;

    // // get velocity
    // // if (Math.abs(a.x) > 0.1 + samples/100000) {     // stop trusting accel data as much as time goes on, need to recalibrate after a while
    //     vel.x += a.x * dt * 0.001;  // using left rectangle sum (Riemann sum)
    //     pos.x += vel.x * dt * 0.001;
    // // }

    // // if (Math.abs(a.y) > 0.1 + samples/100000) {
    //     vel.y += a.y * dt * 0.001;
    //     pos.y += vel.y * dt * 0.001;
    // // }

    // // if (Math.abs(a.z) > 0.1 + samples/100000) {
    //     vel.z += a.z * dt * 0.001;
    //     pos.z += vel.z * dt * 0.001;
    // // }
}

function accelerometerUpdate(e) {
    samples++;

    ctx.clearRect(0, 0, cnvs.width, cnvs.height);
    printY = stepPrintY;

    // Note: these seem to only have 2 digits of precision
    // clone objects because event data read only 
    // var accel = e.accelerationIncludingGravity;
    var accel = e.acceleration;
    var deltaTime = e.interval; 

    time += deltaTime;

    trackPosition(accel, deltaTime);

    printData(ctx, "Accel: ", roundData(accel));

    if (Math.abs(accel.x) > Math.abs(maxAccel.x)) {
        maxAccel.x = accel.x;
    }
    if (Math.abs(accel.y) > Math.abs(maxAccel.y)) {
        maxAccel.y = accel.y;
    }
    if (Math.abs(accel.z) > Math.abs(maxAccel.z)) {
        maxAccel.z = accel.z;
    }
    printData(ctx, "Max Accel Recorded: ", roundData(maxAccel))

    printData(ctx, "dt: ", deltaTime);

    // printData(ctx, "Rotation: ", roundData(rot));
    printData(ctx, "", "");

    printData(ctx, "Velocity: ", roundData(vel));

    if (Math.abs(vel.x) > Math.abs(maxVel.x)) {
        maxVel.x = vel.x;
    }
    if (Math.abs(vel.y) > Math.abs(maxVel.y)) {
        maxVel.y = vel.y;
    }
    if (Math.abs(vel.z) > Math.abs(maxVel.z)) {
        maxVel.z = vel.z;
    }
    printData(ctx, "Max Velocity Recorded: ", roundData(maxVel))
    printData(ctx, "Position: ", roundData(pos));
    printData(ctx, '', '');

    printData(ctx, "not including grav: ", e.acceleration);

    // draw graph of data
    if (document.getElementById("pauseGraph").innerText == "Unpause Graph") {
        return;
    }

    graphCtx.clearRect(samples % graphCnvs.width, 0, 1, graphCnvs.height);

    // accel data
    graphCtx.fillStyle = "black";
    graphCtx.fillRect(samples % graphCnvs.width, graphCnvs.height - accel.y, 1, 1);

    // velocity data
    graphCtx.fillStyle = "red";
    graphCtx.fillRect(samples % graphCnvs.width, graphCnvs.height - (vel.y * graphCnvs.height / 3), 1, 1);   // 100 / 3 to make max value shown 3m/s

    // save graph to storage map (json object)
    // user can then request to export this map as a CSV file
    accelAndVelData[time] = {"accel": accel.y, "vel": vel.y};
}


//================ Event listeners ===============================

if (window.DeviceMotionEvent == undefined) {
    //No accelerometer is present. Use buttons. 
    alert("no accelerometer");
}
else {
    alert("accelerometer found");
    // window.addEventListener("devicemotion", accelerometerUpdate, true);
}

// user can tap screen to set velocity data to 0
window.addEventListener("touchstart", function(e) {
    vel = new vector3(0, 0, 0);
    pos = new vector3(0, 0, 0);

    ctx.fillRect(0, 0, 250, 250);
    // vel = new vector3(0, 0, 0);
})

</script>
</html>