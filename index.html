<html>
    <button id="enableMotion" style="padding: 20px; font-size: 20px;" onclick="enableMotionSensors();">Enable Motion Sensors</button>
    <canvas id="myCanvas"></canvas>
    <canvas id="graphCanvas"></canvas>
<script>
var cnvs = document.getElementById("myCanvas");
cnvs.width = window.innerWidth;
cnvs.height = 500;
var ctx = cnvs.getContext("2d");

var graphCnvs = document.getElementById("graphCanvas");
graphCnvs.width = window.innerWidth;
graphCnvs.height = 100;
var graphCtx = graphCnvs.getContext("2d");

function enableMotionSensors() {
    // thank you DeepSeek for suggestion of why didn't work on IOS
    if (typeof DeviceMotionEvent.requestPermission === 'function') {
        DeviceMotionEvent.requestPermission()
            .then(permissionState => {
                if (permissionState === 'granted') {
                    window.addEventListener("devicemotion", accelerometerUpdate, true);
                } else {
                    alert("Motion permission denied");
                }
            })
            .catch(console.error);
    } else {
        // Non-iOS devices
        window.addEventListener("devicemotion", accelerometerUpdate, true);
    }

    document.getElementById("enableMotion").style.display = 'none';
}

class vector3 {
    constructor(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    mag() {
        return Math.sqrt(this.x ** 2 + this.y ** 2 + this.z ** 2);
    }

    normalize() {
        var m = this.mag();

        this.x /= m;
        this.y /= m;
        this.z /= m;
    }
}

class rotationMatrix {
    // alpha, beta, gamma in radians
    constructor(a, b, g) {
        this.a = a;
        this.b = b;
        this.g = g;

        this.ca = Math.cos(this.a);
        this.cb = Math.cos(this.b);
        this.cg = Math.cos(this.g);
        this.sa = Math.sin(this.a);
        this.sb = Math.sin(this.b);
        this.sg = Math.sin(this.g);

        // define each rotation matrix element
        this.rm = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];

        this.rm[0][0] = this.ca * this.cb;
        this.rm[0][1] = (this.ca * this.sb * this.sg) - (this.sa * this.cg);
        this.rm[0][2] = (this.ca * this.sb * this.cg) + (this.sa * this.sg);
        this.rm[1][0] = this.sa * this.cb;
        this.rm[1][1] = (this.sa * this.sb * this.sg) + (this.ca * this.cg);
        this.rm[1][2] = (this.sa * this.sb * this.cg) - (this.ca * this.sg);
        this.rm[2][0] = -this.sb;
        this.rm[2][1] = this.cb * this.sg;
        this.rm[2][2] = this.cb * this.cg;
    }

    // rotates v of type vector3
    rotateVector3(v) {
        var tmp = new vector3(0, 0, 0);

        tmp.x = this.rm[0][0] * v.x + this.rm[0][1] * v.y + this.rm[0][2] * v.z; 
        tmp.y = this.rm[1][0] * v.x + this.rm[1][1] * v.y + this.rm[1][2] * v.z; 
        tmp.z = this.rm[2][0] * v.x + this.rm[2][1] * v.y + this.rm[2][2] * v.z; 

        v.x = tmp.x;
        v.y = tmp.y;
        v.z = tmp.z;
    }
}

// vars
var samples = 0; // tracks number of IMU samples
var vel = new vector3(0, 0, 0); // velocity in m/s
var maxVel = new vector3(0, 0, 0);
var maxAccel = new vector3(0, 0, 0);
var pos = new vector3(0, 0, 0); // position in m

var stepPrintY = 40;
var printY = stepPrintY;
function printData(context, label, data) {
    ctx.font = "40px Arial";

    var dataStr = "";
    if (typeof data == "object") {
        for (const p in data) {
            dataStr += data[p] + ", ";
        }

        // delete last comma
        dataStr = dataStr.slice(0, dataStr.length - 2);
    } else {
        dataStr = data;
    }

    context.fillText(label + dataStr, 20, printY);
    printY += stepPrintY;
}

// round the data from the IMU
function roundData(data) {
    var tmp = {};

    for (const p in data) {
        tmp[p] = Math.round(data[p] * 100) / 100;
    }

    return tmp;
}

// double integrates linear acceleration to track position
function trackPosition(a, dt) {
    // var prevVel = new vector3(vel.x, vel.y, vel.z);

    // get velocity
    // if (Math.abs(a.x) > 0.1 + samples/100000) {     // stop trusting accel data as much as time goes on, need to recalibrate after a while
        vel.x += a.x * dt * 0.001;
        pos.x += vel.x * dt * 0.001;
    // }

    // if (Math.abs(a.y) > 0.1 + samples/100000) {
        vel.y += a.y * dt * 0.001;
        pos.y += vel.y * dt * 0.001;
    // }

    // if (Math.abs(a.z) > 0.1 + samples/100000) {
        vel.z += a.z * dt * 0.001;
        pos.z += vel.z * dt * 0.001;
    // }
}

function accelerometerUpdate(e) {
    samples++;

    ctx.clearRect(0, 0, cnvs.width, cnvs.height);
    printY = stepPrintY;

    // Note: these seem to only have 2 digits of precision
    // clone objects because event data read only 
    // var accel = e.accelerationIncludingGravity;
    var accel = e.acceleration;
    var deltaTime = e.interval; 

    trackPosition(accel, deltaTime);

    printData(ctx, "Accel: ", roundData(accel));

    if (Math.abs(accel.x) > Math.abs(maxAccel.x)) {
        maxAccel.x = accel.x;
    }
    if (Math.abs(accel.y) > Math.abs(maxAccel.y)) {
        maxAccel.y = accel.y;
    }
    if (Math.abs(accel.z) > Math.abs(maxAccel.z)) {
        maxAccel.z = accel.z;
    }
    printData(ctx, "Max Accel Recorded: ", roundData(maxAccel))

    printData(ctx, "dt: ", deltaTime);

    // printData(ctx, "Rotation: ", roundData(rot));
    printData(ctx, "", "");

    printData(ctx, "Velocity: ", roundData(vel));

    if (Math.abs(vel.x) > Math.abs(maxVel.x)) {
        maxVel.x = vel.x;
    }
    if (Math.abs(vel.y) > Math.abs(maxVel.y)) {
        maxVel.y = vel.y;
    }
    if (Math.abs(vel.z) > Math.abs(maxVel.z)) {
        maxVel.z = vel.z;
    }
    printData(ctx, "Max Velocity Recorded: ", roundData(maxVel))
    printData(ctx, "Position: ", roundData(pos));
    printData(ctx, '', '');

    printData(ctx, "not including grav: ", e.acceleration);

    // draw graph of data
    graphCtx.clearRect(samples % graphCnvs.width, 0, 1, graphCnvs.height);

    // accel data
    graphCtx.fillStyle = "black";
    graphCtx.fillRect(samples % graphCnvs.width, graphCnvs.height - accel.y, 1, 1);

    // velocity data
    graphCtx.fillStyle = "red";
    graphCtx.fillRect(samples % graphCnvs.width, graphCnvs.height - vel.y, 1, 1);
}


//================ Event listeners ===============================

if (window.DeviceMotionEvent == undefined) {
    //No accelerometer is present. Use buttons. 
    alert("no accelerometer");
}
else {
    alert("accelerometer found");
    // window.addEventListener("devicemotion", accelerometerUpdate, true);
}

// user can tap screen to set velocity data to 0
window.addEventListener("touchstart", function(e) {
    vel = new vector3(0, 0, 0);
    pos = new vector3(0, 0, 0);

    ctx.fillRect(0, 0, 250, 250);
    // vel = new vector3(0, 0, 0);
})

</script>
</html>